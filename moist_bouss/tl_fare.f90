!        Generated by TAPENADE     (INRIA, Ecuador team)
!  Tapenade 3.16 (develop) - 31 May 2021 11:17
!
!  Differentiation of fare in forward (tangent) mode:
!   variations   of useful results: pi
!   with respect to varying inputs: pi
!   RW status of diff variables: pi:in-out
SUBROUTINE FARE_D()
    IMPLICIT NONE
  !*** end of while **************  
  ! interface
  !     !This is qv(z) or qvs (z)
  !     pure subroutine FQv(qv,m,dz,qv0)
  !     use, intrinsic :: iso_c_binding
  !     implicit none
  !         integer(C_INT) :: ix,iy,iz
  !         real(C_DOUBLE) :: zk,k0,k1,k2,k3,k4, qvs, pz
  !         integer(C_INT), intent(in) :: m
  !         real(C_DOUBLE), intent(in) :: dz, qv0
  !         real(C_DOUBLE), dimension(m),intent(out) :: qv
  !     end subroutine FQv
  !     !This is dqv/dz for the initial data
  !     pure subroutine Fdqvdz(dqvdz,m,dz,qv0)
  !     use, intrinsic :: iso_c_binding
  !     implicit none
  !         integer(C_INT) :: iz
  !         real(C_DOUBLE) :: k0,z_k,k1,k2,k3,k4, qvs, pz
  !         integer(C_INT), intent(in) :: m
  !         real(C_DOUBLE), intent(in) :: dz, qv0
  !         real(C_DOUBLE), dimension(m),intent(out) :: dqvdz
  !     end subroutine Fdqvdz
  ! end interface
  !Integer
    INTEGER :: it, ix, iy, iz
    INTEGER, SAVE :: nx=128
    INTEGER, SAVE :: ny=128
    INTEGER, SAVE :: m=101
    INTEGER, SAVE :: nxh=65
    INTEGER, SAVE :: nxp=86
    INTEGER, SAVE :: nxph=43
    INTEGER, SAVE :: nyp=86
    INTEGER, SAVE :: nyph=43
    REAL, SAVE :: pi=3.14
    REAL, SAVE :: pid=0.0
    REAL :: us, ts, ths
    REAL :: lx, ly, lz, dx, dy, dz
    REAL :: l, vt, tau, qv0
    REAL :: a_squall, f
    INTEGER :: ls, qs, nn
    REAL :: tfinal, im, eps, epsbar, nz, f_star, g_star, b_star
    REAL :: drx, dry, drz, zk
  !Real
    REAL :: max_theta, max_pert
    REAL :: xi, yj, da, x_c, y_c, z_c, r_c, ampl_bubble
    REAL, DIMENSION(128, 128, 101) :: u, v, w, theta, thetar, qt, qr, qv
    REAL, DIMENSION(101) :: qvini, rc, mr, ubg, vbg, dqvdz, qvs, theta_bar&
  & , u_bar, v_bar, wrk1d, qvs0
    INTEGER :: ti, mindt
    REAL :: dt0, dt, cfl, n_theta
    REAL, DIMENSION(2) :: nu
    COMPLEX, DIMENSION(128, 128) :: in, wrk
    COMPLEX, DIMENSION(65, 128) :: out
  ! complex, dimension(43,86) :: wrk;
    COMPLEX, DIMENSION(101) :: tau_z
  ! complex, dimension(43,86,101) :: uhat, vhat, what, ThetaRhat, qthat
  ! complex, dimension(43,86,101) :: u1hat, v1hat, w1hat, ThetaR1hat, qt1hat
  ! complex, dimension(43,86,101) :: fu1hat, fv1hat, fw1hat, fThetaR1hat, fqt1hat
    COMPLEX, DIMENSION(128, 128, 101) :: uhat, vhat, what, thetarhat, &
  & qthat
    COMPLEX, DIMENSION(128, 128, 101) :: u1hat, v1hat, w1hat, thetar1hat, &
  & qt1hat
    COMPLEX, DIMENSION(128, 128, 101) :: fuhat, fvhat, fwhat, fthetarhat, &
  & fqthat
    COMPLEX, DIMENSION(128, 128, 101) :: fu1hat, fv1hat, fw1hat, &
  & fthetar1hat, fqt1hat
    COMPLEX, DIMENSION(43, 86, 101) :: kx, ky, kk
    COMPLEX, DIMENSION(43, 86, 101) :: e_nu_1, e_nu_2, e_nu_3
    COMPLEX, DIMENSION(43, 86, 101) :: e_nu_1uv, e_nu_2uv, e_nu_3uv
    COMPLEX, DIMENSION(43, 86, 101) :: e_nu_1w, e_nu_2w, e_nu_3w
    COMPLEX, DIMENSION(43, 86, 100) :: a, b, c, rhat, phat
    INTRINSIC SIN
    INTRINSIC EXP
    INTRINSIC SQRT
    INTRINSIC COS
    INTRINSIC SUM
    INTRINSIC ABS
    INTRINSIC MAXVAL
    INTRINSIC MAX
    INTRINSIC MIN
    REAL :: y1
    REAL :: x1
    REAL :: y2
    REAL, DIMENSION(4:m-1) :: abs0
    REAL, DIMENSION(128, 128, 101) :: abs1
    REAL :: max1
    REAL, DIMENSION(128, 128, 101) :: abs2
    REAL, DIMENSION(128, 128, 101) :: abs3
    REAL, DIMENSION(128, 128, 101) :: abs4
    REAL :: arg1
    INTEGER :: pwr1
    REAL :: result1
    REAL, DIMENSION(128, 128, 101) :: arg10
    REAL, DIMENSION(128, 128, 101) :: result10
    COMPLEX, DIMENSION(43, 86, 101) :: arg11
    COMPLEX, DIMENSION(43, 86) :: arg12
    COMPLEX :: arg13
  !----------------PARAMETERS----------------------------------------------
  !Grid size:
  ! nx  = 128; ny  = 128; m  = 100+1;
  ! nxh = nx/2+1; nxp = nx/3; nxp = 2*nxp+1; nxph = (nxp-1)/2+1;
  ! nyp = ny/3; nyp = 2*nyp+1; nyph = (nyp-1)/2+1;
  !Quantity scales:
  !In m/s
    us = 100/9
  !In hours
    ts = 15/60
  !In Kelvin
    ths = 3.0
  !In kms
    ls = 10
  !In g/kg
    qs = 10
  !*******DOMAIN SIZE*******
    lx = 128
    ly = 128
    lz = 15
    lx = lx/ls
    ly = ly/ls
  !Non-dimentionalization
    lz = lz/ls
    dx = lx/nx
    dy = ly/ny
    dz = lz/(m-1)
  !Rain fall velocity
    vt = 5
  !Non-dimentionalization
    vt = vt/us
  !Latent heat
  !In 10^{6}*J*kg^{-1}
    l = 2.5
  !Non-dimentionalization prefector epsilon^{-1} L = epsilon^2 * L^d * \theta_0 ([\Theta]*c_p*T_0)^{-1}
    l = l/3*10
  !Pendiente: Cambiar a LcpTheta0
  !Relaxation time
  ! In hours
    tau = 4
  !Non-dimensionalization
    tau = tau/ts
  !Turned off
    tau = 0
  !Qvs at surface
  !In g/kg
    qvs0 = 20
  !Non-dimensionalization 
    qvs0 = qvs0/qs
  !In g/kg
    qv0 = 18
    qv0 = qv0/qs
  !Max perturbation in theta
  !In Kelvin
    max_pert = 0.1*0
  !Non-dimensionalization
    max_pert = max_pert/ths
  !Parameter for the zonal vel background
  !In m/s
    a_squall = 10
    a_squall = a_squall/us
  !Turned off
    a_squall = a_squall*0
  !Coriolis parameter
    f = SIN(25*pi/180)
  !Final time
  !In hours
    tfinal = 5
  !Non-dimensionalization
    tfinal = tfinal/ts
    im = (0,1)
  !***************
  !***************
    eps = 0.1
    epsbar = 0.622
    nz = 1
  !***************
    f_star = eps*f
  !7.9461;
    g_star = 10
    b_star = 10
  !Wave numbers are multiple of those
    drx = 2*pi/lx
    dry = 2*pi/ly
    drz = 2*pi/lz
  !!!!Data for Bubble:
    x_c = lx/2
    y_c = ly/2
    z_c = 2/ls
  !rx_c = 10; ry_c = 10; rz_c = 1;
  !rx_c = rx_c/Ls; ry_c = ry_c/Ls; rz_c = rz_c/Ls; 
    ampl_bubble = 8/4/qs
    r_c = 5
    r_c = r_c/ls
  !-------Allocation----------------------
  !-------------------FFTW PACKAGE-----------------------------------------
  !---------------GENERATING RANDOM NUMBERS FOR THE PERTURBATION-----------------------------------
  !---------------FUNCTIONS-----------------------------------
    DO ix=1,nxph
      kx(ix, :, :) = ix - 1
      DO iy=1,nyph
        ky(ix, iy, :) = iy - 1
      END DO
      DO iy=nyph+1,nyp
        ky(ix, iy, :) = iy - nyp - 1
      END DO
    END DO
    kx = drx*kx
    ky = dry*ky
    kk = kx*kx + ky*ky
    DO iz=1,m
      qvs0(m) = 18.04 + 3.27 + 0.1 + 0.1804 + 3.48
      qvini(m) = 18.04 + 3.27 + 0.1 + 0.1804 + 3.48
      dqvdz = 18.04 + 3.27 + 0.1
    END DO
  ! call FQv(qvs,m,dz,qvs0);
  ! call FQv(qvini,m,dz,qv0);
  ! call Fdqvdz(dqvdz,m,dz,qv0);
    theta = 0
  !Define the radiactive cooling rate
  !Turned off
    rc = 0
  !do iz=1,m
  !	zk = (iz-0.5)*dz;
  !	RC(iz) = -exp(-0.2*zk)*zk*(1.5-zk)**2;
  !	RC(iz) = RC(iz)*(1/0.45)*(1/288)*25; !Profile similar to Majda-Xing, max about 25 K/day
  !end do 
  !Define the moistening proportional to dqvdz
  !Turned off
    mr = 0
  !do iz=1,m
  !	Mr(iz) = 0.1*RC(iz)*dqvdz(iz)*0; !Turned off
  !end do
  !!!!!!!!!!!!!!!!!!----Damping in w: ----
    tau_z = 0
    DO iz=1,m
      zk = (iz-1)*dz
      arg1 = 50*((1/lz)**2-(1/(zk-lz))**2)
      tau_z(iz) = 1/(1/ts)*EXP(arg1)
    END DO
  !Turned off
    tau_z = 0
    ubg = 0
  !Turned off
    vbg = 0
  !!!!!!!!!!!!!!!Pressure solver !!!!
  !Three diagonals for Thomas' method
  !Main diagonal (entries from 1 to m-1), to compute variables in the staggered grid, level at p
    b = -(kk(:, :, :m-1)+1/dz**2)
    b(:, :, 2:m-2) = b(:, :, 2:m-2) - 1/dz**2
    b(1, 1, 1) = 1/dz**2
  ! 1; !Pendiente
    b(1, 1, m-1) = -(1/dz**2)
    a = 1/dz**2
  !Lower diagonal, a_2, a_3, ... a_{m-1}
    a(:, :, 1) = 0
    c = 1/dz**2
  !Upper diagonal: c_1, c_2 ... c_{m-2}
    c(:, :, m-1) = 0
    c(1, 1, 1) = 0
  !--------------INITIAL DATA-----------------------------------------------
    u = 0
    v = 0
    w = 0
    theta = 0
    qv = 0
    qr = 0
  !---------Perturbation in temperature-------------------
  !Turned off
    theta = 0
  !-------Moist bubble
    qt = 0
    DO iy=1,ny
      yj = (iy-1)*dy
      DO ix=1,nx
        xi = (ix-1)*dx
        arg1 = (xi-x_c)**2 + (yj-y_c)**2
        da = SQRT(arg1)
        DO iz=1,m-1
  !For level at u
          zk = (iz-0.5)*dz
          IF (da .LE. r_c .AND. zk .GE. z_c - 0.1 .AND. zk .LE. z_c + 0.1&
  &       ) THEN
  !*(10*(zk-z_c-0.3))**2;
            arg1 = pi*da/(2*r_c)
            qt(ix, iy, iz) = ampl_bubble*COS(arg1)*(10*(zk-z_c-0.1))**2*(&
  &           10*(zk-z_c+0.1))**2
  !if ( qvini(iz)+qv(ix,iy,iz) > qvs(iz) ) then
  !	print*,'Reduce amplitude'
  !	stop
  !end if
          END IF
        END DO
      END DO
    END DO
  !print*,maxval(qv(:,ny/2,:))*qs, ampl_bubble*qs, r_c*Ls, pi
  !stop
    qr = 0
    DO iz=1,m
      WHERE (qvini(iz) + qt(:, :, iz) .GT. qvs(iz)) qr(:, :, iz) = qvini(&
  &       iz) + qt(:, :, iz) - qvs(iz)
      qv(:, :, iz) = qt(:, :, iz) - qr(:, :, iz)
      WHERE (qv(:, :, iz) + qvini(iz) .LT. 0) qv(:, :, iz) = -qvini(iz)
    END DO
    qt = qv + qr
    thetar = theta - l*qr
  !----Pass to Fourier space---------------------------------------------------------
    nn = nx*ny
    DO iz=1,m
      in = u(:, :, iz)
      wrk = in
      uhat(:, :, iz) = wrk/nn
      in = v(:, :, iz)
  !--------------------------------
      wrk = in
      vhat(:, :, iz) = wrk/nn
      in = w(:, :, iz)
  !--------------------------------
      wrk = in
      what(:, :, iz) = wrk/nn
      in = thetar(:, :, iz)
  !--------------------------------
      wrk = in
      thetarhat(:, :, iz) = wrk/nn
      in = qt(:, :, iz)
  !--------------------------------
      wrk = in
      qthat(:, :, iz) = wrk/nn
    END DO
    uhat(1, 1, :) = ubg
  !--------------------------------	
    vhat(1, 1, :) = vbg
    DO iz=1,m
      wrk = uhat(:, :, iz)
      wrk = in
      u(:, :, iz) = in
  !-------------------------
      wrk = vhat(:, :, iz)
      wrk = in
      v(:, :, iz) = in
    END DO
  !-------------------------
  !----- Time iteration start----------------------
    ti = 0
    pwr1 = 10**(-3)
    dt0 = 2.5*pwr1
    nu = 0
  !0.1/(((pi/dx)**2)**2 * dt0); !
    pwr1 = 10**(-5)
    nu(1) = 4*pwr1/1
  !0.005*(dz**2)/dt0; !
    pwr1 = 10**(-4)
    nu(2) = 4*pwr1/1
    cfl = 0.9
    mindt = 1
    max_theta = 0
    dt = dt0
  !print*,'started'
    DO WHILE (ti .LE. tfinal + 5*dt)
  !---------------------------------------------------
      DO iz=1,m
        theta_bar(iz) = SUM(theta(:, :, iz))/(nx*ny)
      END DO

      
      WHERE ((theta_bar(4:m-1)-theta_bar(2:m-3))/(2*dz) .GE. 0.0) 
        abs0 = (theta_bar(4:m-1)-theta_bar(2:m-3))/(2*dz)
      ELSEWHERE
        abs0 = -((theta_bar(4:m-1)-theta_bar(2:m-3))/(2*dz))
      END WHERE
      result1 = MAXVAL(abs0)
      n_theta = (81+8.1*result1)**0.5
      dt = dt0
      arg10(:, :, :) = u*u/dx**2 + v*v/dy**2 + w*w/dz**2
      result10 = SQRT(arg10(:, :, :))
      x1 = MAXVAL(result10)
      WHERE (u .GE. 0.0) 
        abs2 = u
      ELSEWHERE
        abs2 = -u
      END WHERE
      WHERE (v .GE. 0.0) 
        abs3 = v
      ELSEWHERE
        abs3 = -v
      END WHERE
      WHERE (w .GE. 0.0) 
        abs4 = w
      ELSEWHERE
        abs4 = -w
      END WHERE
      arg10(:, :, :) = abs2/dx + abs3/dy + abs4/dz
      y2 = MAXVAL(arg10(:, :, :))
      IF (x1 .LT. y2) THEN
        IF (y2 .LT. 1.0) THEN
          max1 = 1.0
        ELSE
          max1 = y2
        END IF
      ELSE IF (x1 .LT. 1.0) THEN
        max1 = 1.0
      ELSE
        max1 = x1
      END IF
      y1 = cfl/max1
      IF (dt .GT. y1) THEN
        dt = y1
      ELSE
        dt = dt
      END IF
      IF (dt .GT. pi/(10*n_theta)) THEN
        dt = pi/(10*n_theta)
      ELSE
        dt = dt
      END IF



      arg11(:, :, :) = dt/3*(-(nu(1)*kk**2)-nu(2)*2/dz**2)
      e_nu_1 = EXP(arg11(:, :, :))
      e_nu_2 = e_nu_1**2
      e_nu_3 = e_nu_1**3
      DO iz=1,m
  !Damping in all modes
        arg12(:, :) = dt/3*(-(nu(1)*kk(:, :, iz)**2)-nu(2)*2/dz**2-tau_z(&
  &       iz))
        e_nu_1uv(:, :, iz) = EXP(arg12(:, :))
  !1; !Removing the viscosity in the bar quantities and adding damping
        e_nu_1uv(1, 1, iz) = EXP(dt/3*(-tau_z(iz)))
        e_nu_2uv(:, :, iz) = e_nu_1uv(:, :, iz)**2
        e_nu_3uv(:, :, iz) = e_nu_1uv(:, :, iz)**3
      END DO
      DO iz=1,m
  !Damping in all modes
        arg12(:, :) = dt/3*(-(nu(1)*kk(:, :, iz)**2)-nu(2)*2/dz**2-tau_z(&
  &       iz))
        e_nu_1w(:, :, iz) = EXP(arg12(:, :))
        arg13 = dt/3*(-(nu(2)*2/dz**2)-tau_z(iz))
        e_nu_1w(1, 1, iz) = EXP(arg13)
        e_nu_2w(:, :, iz) = e_nu_1w(:, :, iz)**2
        e_nu_3w(:, :, iz) = e_nu_1w(:, :, iz)**3
      END DO
      WHERE (theta .GE. 0.0) 
        abs1 = theta
      ELSEWHERE
        abs1 = -theta
      END WHERE
  !max(max_theta,maxval(abs(Theta)));
      max_theta = MAXVAL(abs1)
      PRINT*, 'T=', ti*ts, ' hours'
      PRINT*, 'max_theta=', max_theta*ths, ' kelvin'
  !---------------------------------------------------
  !---- RK3 for momentum equations start ---------
  !****- RK1  start ********************************
  ! call RK_flux(nx,nxh,nxph,ny,nyp,nyph,m,kx,ky,dx,dz,f_star,g_star,epsbar,L,B_star,nu,vt,uhat,vhat,what,ThetaRhat,qthat,u,v,w,The
  !taR,qt,&
  ! fuhat,fvhat,fwhat,fThetaRhat,fqthat,RC,Mr,ubg,vbg,tau,qvs,qvini,dqvdz,in,out,planf)
      PRINT*, 'rk_flux'
      u1hat = (uhat+dt/3*fuhat)*e_nu_1uv
      v1hat = (vhat+dt/3*fvhat)*e_nu_1uv
      w1hat = (what+dt/3*fwhat)*e_nu_1w
      thetar1hat = (thetarhat+dt/3*fthetarhat)*e_nu_1
      qt1hat = (qthat+dt/3*fqthat)*e_nu_1
      rhat(:, :, 1:m-1) = im*kx(:, :, 1:m-1)*u1hat(:, :, 1:m-1) + im*ky(:&
  &     , :, 1:m-1)*v1hat(:, :, 1:m-1) + (w1hat(:, :, 2:m)-w1hat(:, :, 1:m&
  &     -1))/dz
  !******- Possion equation for pressure p -*******
      phat = 0
  ! call Thomas(phat,a,b,c,rhat,nxph,nyp,m-1);
      PRINT*, 'thomas poisson'
  !***- Update veloctiy field ----------------------
      u1hat(:, :, 1:m-1) = u1hat(:, :, 1:m-1) - im*kx(:, :, 1:m-1)*phat
      v1hat(:, :, 1:m-1) = v1hat(:, :, 1:m-1) - im*ky(:, :, 1:m-1)*phat
      w1hat(:, :, 2:m-1) = w1hat(:, :, 2:m-1) - (phat(:, :, 2:m-1)-phat(:&
  &     , :, 1:m-2))/dz
      w1hat(:, :, 1) = 0
      w1hat(:, :, m) = 0
  !***Neumann boundary condition, w1hat(1)=w1hat(1),w1hat(m)=w1hat(m)***
  !--- Get u1,v1,w1 & ThetaR1 ---
      DO iz=1,m
        wrk = u1hat(:, :, iz)
        wrk = in
        u(:, :, iz) = in
  !-------------------------
        wrk = v1hat(:, :, iz)
        wrk = in
        v(:, :, iz) = in
  !-------------------------
        wrk = w1hat(:, :, iz)
        wrk = in
        w(:, :, iz) = in
  !-------------------------
        wrk = thetar1hat(:, :, iz)
        wrk = in
        thetar(:, :, iz) = in
  !-------------------------
        wrk = qt1hat(:, :, iz)
        wrk = in
        qt(:, :, iz) = in
      END DO
  !************  RK1 end ***********************************
  !****- RK2  start ********************************
  ! call RK_flux(nx,nxh,nxph,ny,nyp,nyph,m,kx,ky,dx,dz,f_star,g_star,epsbar,L,B_star,nu,vt,u1hat,v1hat,w1hat,ThetaR1hat,qt1hat,u,v,
  !w,ThetaR,qt,&
  ! fu1hat,fv1hat,fw1hat,fThetaR1hat,fqt1hat,RC,Mr,ubg,vbg,tau,qvs,qvini,dqvdz,in,out,planf)
      PRINT*, 'rk_flux'
      u1hat = uhat*e_nu_2uv + 2/3*dt*fu1hat*e_nu_1uv
      v1hat = vhat*e_nu_2uv + 2/3*dt*fv1hat*e_nu_1uv
      w1hat = what*e_nu_2w + 2/3*dt*fw1hat*e_nu_1w
      thetar1hat = thetarhat*e_nu_2 + 2/3*dt*fthetar1hat*e_nu_1
      qt1hat = qthat*e_nu_2 + 2/3*dt*fqt1hat*e_nu_1
      rhat(:, :, 1:m-1) = im*kx(:, :, 1:m-1)*u1hat(:, :, 1:m-1) + im*ky(:&
  &     , :, 1:m-1)*v1hat(:, :, 1:m-1) + (w1hat(:, :, 2:m)-w1hat(:, :, 1:m&
  &     -1))/dz
  !******- Possion equation for pressure p -*******
      phat = 0
  ! call Thomas(phat,a,b,c,rhat,nxph,nyp,m-1);
      PRINT*, 'thomas poisson'
  !*************************************************
  !***- Update veloctiy field ----------------------
      u1hat(:, :, 1:m-1) = u1hat(:, :, 1:m-1) - im*kx(:, :, 1:m-1)*phat
      v1hat(:, :, 1:m-1) = v1hat(:, :, 1:m-1) - im*ky(:, :, 1:m-1)*phat
      w1hat(:, :, 2:m-1) = w1hat(:, :, 2:m-1) - (phat(:, :, 2:m-1)-phat(:&
  &     , :, 1:m-2))/dz
      w1hat(:, :, 1) = 0
      w1hat(:, :, m) = 0
  !***Neumann boundary condition, w1hat(1)=w1hat(1),w1hat(m)=w1hat(m)***
  !--- Get u1,v1,w1 & ThetaR1 ---
      DO iz=1,m
        wrk = u1hat(:, :, iz)
        wrk = in
        u(:, :, iz) = in
  !-------------------------
        wrk = v1hat(:, :, iz)
        wrk = in
        v(:, :, iz) = in
  !-------------------------
        wrk = w1hat(:, :, iz)
        wrk = in
        w(:, :, iz) = in
  !-------------------------
        wrk = thetar1hat(:, :, iz)
        wrk = in
        thetar(:, :, iz) = in
  !-------------------------
        wrk = qt1hat(:, :, iz)
        wrk = in
        qt(:, :, iz) = in
      END DO
  !------------------------
  !************  RK2 end ***************************
  !****- RK3  start ********************************
  ! call RK_flux(nx,nxh,nxph,ny,nyp,nyph,m,kx,ky,dx,dz,f_star,g_star,epsbar,L,B_star,nu,vt,u1hat,v1hat,w1hat,ThetaR1hat,qt1hat,u,v,
  !w,ThetaR,qt,&
  ! fu1hat,fv1hat,fw1hat,fThetaR1hat,fqt1hat,RC,Mr,ubg,vbg,tau,qvs,qvini,dqvdz,in,out,planf)
      PRINT*, 'rk_flux'
      uhat = uhat*e_nu_3uv + dt/4*fuhat*e_nu_3uv + 3/4*dt*fu1hat*e_nu_1uv
      vhat = vhat*e_nu_3uv + dt/4*fvhat*e_nu_3uv + 3/4*dt*fv1hat*e_nu_1uv
      what = what*e_nu_3w + dt/4*fwhat*e_nu_3w + 3/4*dt*fw1hat*e_nu_1w
      thetarhat = thetarhat*e_nu_3 + dt/4*fthetarhat*e_nu_3 + 3/4*dt*&
  &     fthetar1hat*e_nu_1
      qthat = qthat*e_nu_3 + dt/4*fqthat*e_nu_3 + 3/4*dt*fqt1hat*e_nu_1
      rhat(:, :, 1:m-1) = im*kx(:, :, 1:m-1)*uhat(:, :, 1:m-1) + im*ky(:, &
  &     :, 1:m-1)*vhat(:, :, 1:m-1) + (what(:, :, 2:m)-what(:, :, 1:m-1))/&
  &     dz
  !******- Possion equation for pressure p -*******
      phat = 0
  ! call Thomas(phat,a,b,c,rhat,nxph,nyp,m-1);
      PRINT*, 'thomas poisson'
  !***- Update veloctiy field ----------------------
      uhat(:, :, 1:m-1) = uhat(:, :, 1:m-1) - im*kx(:, :, 1:m-1)*phat
      vhat(:, :, 1:m-1) = vhat(:, :, 1:m-1) - im*ky(:, :, 1:m-1)*phat
      what(:, :, 2:m-1) = what(:, :, 2:m-1) - (phat(:, :, 2:m-1)-phat(:, :&
  &     , 1:m-2))/dz
      what(:, :, 1) = 0
      what(:, :, m) = 0
  !***Neumann boundary condition, what(1)=what(1),what(m)=what(m)***
  !--- Get u1,v1,w1 & ThetaR1 ---
      DO iz=1,m
        wrk = uhat(:, :, iz)
        wrk = in
        u(:, :, iz) = in
  !-------------------------
        wrk = vhat(:, :, iz)
        wrk = in
        v(:, :, iz) = in
  !-------------------------
        wrk = what(:, :, iz)
        wrk = in
        w(:, :, iz) = in
  !-------------------------
        wrk = thetarhat(:, :, iz)
        wrk = in
        thetar(:, :, iz) = in
  !-------------------------
        wrk = qthat(:, :, iz)
        wrk = in
        qt(:, :, iz) = in
      END DO
  !************  RK3 end ***************************
  !Now we need to impose positivity in qv+qvini
      qr = 0
      DO iz=1,m
        WHERE (qvini(iz) + qt(:, :, iz) .GT. qvs(iz)) qr(:, :, iz) = qvini&
  &         (iz) + qt(:, :, iz) - qvs(iz)
        qv(:, :, iz) = qt(:, :, iz) - qr(:, :, iz)
        WHERE (qv(:, :, iz) + qvini(iz) .LT. 0) qv(:, :, iz) = -qvini(iz)
      END DO
      qt = qv + qr
      theta = thetar + l*qr
  !Now we need to recompute theta,qr,qv to be in agreement with the modification
  !print*,'min qv tot=',minval(qvini+qv)
  !We still need to pass ThetaR, qt to Fourier space
      DO iz=1,m
        in = thetar(:, :, iz)
  !--------------------------------
        wrk = in
        thetarhat(:, :, iz) = wrk/nn
        in = qt(:, :, iz)
  !--------------------------------
        wrk = in
        qthat(:, :, iz) = wrk/nn
      END DO
      ti = ti + dt
  !---------------------------------------------------
    END DO
  END SUBROUTINE FARE_D