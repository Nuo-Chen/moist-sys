C        Generated by TAPENADE     (INRIA, Ecuador team)
C  Tapenade 3.16 (develop) - 31 May 2021 11:17
C
C  Differentiation of fwd in forward (tangent) mode:
C   variations   of useful results: w bs bu
C   with respect to varying inputs: w bs bu
C   RW status of diff variables: w:in-out bs:in-out bu:in-out
C234567
      SUBROUTINE FWD_D(nt, w, wd, bu, bud, bs, bsd, nu, ns, dt)
      IMPLICIT NONE
      INTEGER nt, t
      REAL dt, nu, ns
      REAL w(nt), bu(nt), bs(nt)
      REAL wd(nt), bud(nt), bsd(nt)
      nu = 0.012
      ns = 0.0012
      dt = 0.1
C
      wd(1) = 0.0
      w(1) = 0.1
      bsd(1) = 0.0
      bs(1) = 0
      bud(1) = 0.0
      bu(1) = 0
      DO t=1,nt-1
        IF (bs(t) .LT. bu(t)) THEN
          wd(t+1) = wd(t) + nu*dt*bud(t)
          w(t+1) = w(t) + nu*bu(t)*dt
        ELSE
          wd(t+1) = wd(t) + ns*dt*bsd(t)
          w(t+1) = w(t) + ns*bs(t)*dt
        END IF
C
        bud(t+1) = bud(t) - nu**2*dt*wd(t)
        bu(t+1) = bu(t) - nu*nu*w(t)*dt
        bsd(t+1) = bsd(t) - ns**2*dt*wd(t)
        bs(t+1) = bs(t) - ns*ns*w(t)*dt
      ENDDO
C
      RETURN
      END
      
CCCCCCCCCCCCCCCCCCCCCCCCC
C        Generated by TAPENADE     (INRIA, Ecuador team)
C  Tapenade 3.16 (develop) - 31 May 2021 11:17
C
C  Differentiation of fwd in reverse (adjoint) mode:
C   gradient     of useful results: w bs bu
C   with respect to varying inputs: w bs bu
C   RW status of diff variables: w:in-out bs:in-out bu:in-out
C234567
      SUBROUTINE FWD_B(nt, w, wb, bu, bub, bs, bsb, nu, ns, dt)
      IMPLICIT NONE
      INTEGER nt, t
      REAL dt, nu, ns
      REAL w(nt), bu(nt), bs(nt)
      REAL wb(nt), bub(nt), bsb(nt)
      INTEGER branch
      nu = 0.012
      ns = 0.0012
      dt = 0.1
C
      w(1) = 0.1
      bs(1) = 0
      bu(1) = 0
      DO t=1,nt-1
        IF (bs(t) .LT. bu(t)) THEN
          w(t+1) = w(t) + nu*bu(t)*dt
          CALL PUSHCONTROL1B(0)
        ELSE
          w(t+1) = w(t) + ns*bs(t)*dt
          CALL PUSHCONTROL1B(1)
        END IF
C
        bu(t+1) = bu(t) - nu*nu*w(t)*dt
        bs(t+1) = bs(t) - ns*ns*w(t)*dt
      ENDDO
      DO t=nt-1,1,-1
        bsb(t) = bsb(t) + bsb(t+1)
        wb(t) = wb(t) - dt*ns**2*bsb(t+1) - dt*nu**2*bub(t+1)
        bsb(t+1) = 0.0
        bub(t) = bub(t) + bub(t+1)
        bub(t+1) = 0.0
        CALL POPCONTROL1B(branch)
        IF (branch .EQ. 0) THEN
          wb(t) = wb(t) + wb(t+1)
          bub(t) = bub(t) + nu*dt*wb(t+1)
          wb(t+1) = 0.0
        ELSE
          wb(t) = wb(t) + wb(t+1)
          bsb(t) = bsb(t) + ns*dt*wb(t+1)
          wb(t+1) = 0.0
        END IF
      ENDDO
      
      
      SUBROUTINE PUSHCONTROL1B(cc)
      INTEGER cc
      CALL PUSHBIT(cc.ne.0)
      END

      SUBROUTINE POPCONTROL1B(cc)
      INTEGER cc
      LOGICAL POPBIT
      IF (POPBIT()) THEN
         cc = 1
      ELSE
         cc = 0
      ENDIF
      END
      
      SUBROUTINE PUSHBIT(bit)
      LOGICAL bit
      INTEGER*4 adbitbuf
      INTEGER adbitibuf
      COMMON /adbitfbuf/adbitbuf, adbitibuf
      IF (bit) THEN
         adbitbuf = IBSET(adbitbuf, adbitibuf)
      ELSE
         adbitbuf = IBCLR(adbitbuf, adbitibuf)
      ENDIF
      IF (adbitibuf.ge.31) THEN
         CALL PUSHNARRAY(adbitbuf, 4, 1)
         adbitbuf = 0
         adbitibuf = 0
      ELSE
         adbitibuf = adbitibuf+1
      ENDIF
      END
      
      LOGICAL FUNCTION POPBIT()
      INTEGER*4 adbitbuf
      INTEGER adbitibuf
      COMMON /adbitfbuf/adbitbuf, adbitibuf
      IF (adbitibuf.le.0) THEN
         CALL POPNARRAY(adbitbuf, 4, 1)
         adbitibuf = 31
      ELSE
         adbitibuf = adbitibuf-1
      ENDIF
      POPBIT = BTEST(adbitbuf, adbitibuf)
      END